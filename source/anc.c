#include <inttypes.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "args.h"
#include "buffer.h"
#include "cache.h"
#include "paging.h"
#include "profile.h"
#include "shuffle.h"
#include "sysfs.h"
#include "thread.h"
#include "macros.h"
#include "path.h"

#if defined(__i386__) || defined(__x86_64__)
#include <cpuid/cache.h>
#include <cpuid/cpuid.h>
#endif

int main()
{
	struct args args = {
		.npages = { 128, 128, 128, 128 },
		.nentries = { SIZE_MAX, SIZE_MAX, SIZE_MAX, SIZE_MAX },
		.nrounds = 10,
		.line_size = 64,
		.nruns = 1
	};
	struct buffer *buffer;
	struct cache *cache;
	struct page_format *page_format;
	size_t run;
	size_t i;
	unsigned num_errors = 0;
	unsigned total_slot_errors = 0;
	unsigned total_slot_error_distances = 0;
	unsigned slot_errors;
	int ret = -1;

	detect_args(&args);

	page_format = get_page_format_from_args(&args);

	init_profiler();
	pin_cpu(args.cpu);

	buffer = new_buffer(page_format, (void *)args.target);

	if (!(cache = new_cache(page_format, NULL, args.cache_size, args.line_size))) {
		printf("unable to allocate the eviction set.\n");
		goto err_del_buffer;
	}

	srand(time(0));

	printf("\nTarget virtual address: %p\n", buffer->data);

	for (run = 0; run < args.nruns; ++run) {
		printf("\n");

		unsigned slot_error_distances[page_format->nlevels];
		slot_errors = profile_page_tables(slot_error_distances, cache, page_format, args.nrounds, buffer->data);

		num_errors += (slot_errors > 0);
		total_slot_errors += slot_errors;

		for (i = 0; i < slot_errors; ++i)
			total_slot_error_distances += slot_error_distances[i];
	}

	ret = 0;
	del_cache(cache);

err_del_buffer:
	del_buffer(buffer);

	if (args.page_format)
		free(args.page_format);

	return ret;
}
