#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <cache.h>
#include <cpuid.h>

#include <getopt.h>

#include "args.h"
#include "paging.h"

void detect_args(struct args *args)
{
	union cache_desc cache_descs[32], *cache_desc;
	size_t nentries[4] = {0, 0, 0, 0};
	size_t ncache_descs, i;

	ncache_descs = get_cache_descs(cache_descs, 32);

	args->cache_size = 0;
	args->line_size = 0;

	for (i = 0; i < ncache_descs; ++i) {
		cache_desc = cache_descs + i;

		switch (get_cache_desc_type(cache_desc)) {
		case CACHE_DESC_TLB:
			if (!(cache_desc->flags & CACHE_DESC_DATA))
				break;

			if ((cache_desc->tlb.page_size & TLB_4K_PAGE)) {
				nentries[0] += cache_desc->tlb.nentries;
			}

			if ((cache_desc->tlb.page_size & TLB_2M_PAGE)) {
				nentries[1] += cache_desc->tlb.nentries;
			}

			if ((cache_desc->tlb.page_size & TLB_1G_PAGE)) {
				nentries[2] += cache_desc->tlb.nentries;
			}

			break;
		case CACHE_DESC_CACHE:
			if (!(cache_desc->flags & CACHE_DESC_DATA))
				break;

			args->line_size = max(args->line_size,
				cache_desc->cache.line_size);
			args->cache_size = max(args->cache_size,
				cache_desc->cache.size);
			break;
		default: break;
		}
	}

	for (i = 0; i < 4; ++i) {
		if (args->nentries[i] == SIZE_MAX)
			args->nentries[i] = nentries[i];
	}
}

struct page_format *get_page_format_from_args(struct args *args)
{
	struct page_format *fmt = get_default_page_format();
	struct page_level *level;
	size_t i;

	for (i = 0, level = fmt->levels; i < fmt->nlevels; ++level, ++i) {
		level->npages = args->npages[i];
		level->ncache_entries = args->nentries[i];
	}

	return fmt;
}
